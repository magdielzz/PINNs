<!DOCTYPE html>
<html lang="es" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redes Neuronales Informadas por la Física (PINNs) para la Ecuación de Schrödinger No Lineal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-2.20.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        body {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            font-family: 'Inter', sans-serif;
        }
        
        .glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .section-card {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.15);
        }
        
        .nav-link {
            transition: all 0.3s ease;
        }
        
        .nav-link:hover {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }
        
        .equation-card {
            background: linear-gradient(145deg, #f8fafc, #e2e8f0);
            border-left: 4px solid #3b82f6;
        }
        
        .code-block {
            background: #1e293b;
            color: #e2e8f0;
            border-radius: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            white-space: pre-wrap;
        }
        
        .tooltip {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }
        
        .has-tooltip:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
        
        .loss-term {
            transition: all 0.3s ease;
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            display: inline-block;
            margin: 2px;
        }
        
        .loss-term:hover {
            background: #e0f2fe;
            transform: scale(1.05);
        }

        .pinn-architecture {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }
        
        .neuron-layer {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .neuron {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: linear-gradient(145deg, #60a5fa, #3b82f6);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }
        
        .connection {
            width: 40px;
            height: 2px;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
        }
        .chart-container {
            position: relative;
            width: 100%;
            height: 40vh;
            max-height: 400px;
        }
    </style>
</head>
<body class="antialiased text-gray-800">

    <header class="fixed top-0 w-full z-50 glass">
        <nav class="container mx-auto px-6 py-4">
            <div class="flex justify-between items-center">
                <h1 class="text-2xl font-bold text-white">PINNs para NLS</h1>
                <div class="hidden md:flex space-x-4 text-white text-sm">
                    <a href="#introduccion" class="nav-link px-3 py-2">Introducción</a>
                    <a href="#marco-teorico" class="nav-link px-3 py-2">Marco Teórico</a>
                    <a href="#derivacion" class="nav-link px-3 py-2">Derivación</a>
                    <a href="#soluciones" class="nav-link px-3 py-2">Soluciones</a>
                    <a href="#visualizaciones" class="nav-link px-3 py-2">Visualizaciones</a>
                    <a href="#pinn-teoria" class="nav-link px-3 py-2">Teoría PINN</a>
                    <a href="#implementacion" class="nav-link px-3 py-2">Implementación</a>
                    <a href="#resultados" class="nav-link px-3 py-2">Resultados</a>
                    <a href="#conclusion" class="nav-link px-3 py-2">Conclusión</a>
                    <a href="#referencias" class="nav-link px-3 py-2">Referencias</a>
                </div>
            </div>
        </nav>
    </header>

    <main class="pt-20">
        <section class="relative py-20 text-center text-white">
            <div class="container mx-auto px-6">
                <h1 class="text-5xl font-bold mb-6">Redes Neuronales Informadas por la Física</h1>
                <h2 class="text-3xl font-light mb-8">Resolución de la Ecuación de Schrödinger No Lineal</h2>
                <p class="text-xl max-w-4xl mx-auto mb-12 opacity-90">
                    Una exploración de la aplicación de PINNs para resolver la ecuación de Schrödinger no lineal (NLS), combinando el poder del aprendizaje profundo con las leyes fundamentales de la física para acelerar y mejorar las simulaciones científicas.
                </p>
            </div>
        </section>

        <div class="container mx-auto px-6 space-y-20 pb-20">

            <section id="introduccion" class="section-card p-12">
                <h2 class="text-4xl font-bold text-gray-800 mb-8 text-center">Introducción</h2>
                <div class="grid md:grid-cols-2 gap-12 items-center">
                    <div>
                        <h3 class="text-2xl font-semibold text-gray-700 mb-6">Un Nuevo Paradigma en Simulación</h3>
                        <p class="text-gray-600 mb-6 text-lg leading-relaxed">
                            Tradicionalmente, resolver ecuaciones diferenciales parciales (EDPs) complejas ha requerido supercomputadoras y métodos numéricos que, aunque potentes, pueden ser lentos y computacionalmente costosos. Las Redes Neuronales Informadas por la Física (PINNs) emergen como una alternativa revolucionaria que fusiona el poder de aproximación de las redes neuronales con el conocimiento fundamental de la física, codificado en las propias EDPs.
                        </p>
                         <p class="text-gray-600 mb-6 text-lg leading-relaxed">
                            En lugar de depender únicamente de datos, las PINNs utilizan la propia ecuación como un término de regularización en su entrenamiento. Esto no solo reduce la necesidad de grandes volúmenes de datos de entrenamiento, sino que también garantiza que las soluciones generadas sean físicamente consistentes y coherentes. Este proyecto explora esta técnica para resolver la Ecuación de Schrödinger No Lineal (NLS), un pilar en la física de ondas.
                        </p>
                    </div>
                    <div class="equation-card p-8">
                        <h3 class="text-2xl font-semibold text-gray-700 mb-6 text-center">Ecuación de Schrödinger No Lineal (NLS)</h3>
                        <div class="text-center text-2xl text-gray-800 mb-6">
                            $$i h_t + \frac{1}{2} h_{xx} + |h|^2 h = 0$$
                        </div>
                        <p class="text-gray-600 text-center">
                            Esta ecuación es fundamental para describir la evolución de ondas no lineales en sistemas como la óptica, los condensados de Bose-Einstein y las ondas de agua profunda. Nuestro objetivo es usar una PINN para encontrar su solución compleja h(x,t).
                        </p>
                    </div>
                </div>
            </section>
            
            <section id="marco-teorico" class="section-card p-12">
                <h2 class="text-4xl font-bold text-gray-800 mb-8 text-center">Marco Teórico: ¿Por qué PINNs?</h2>
                <div class="max-w-4xl mx-auto space-y-8 text-lg text-gray-600 leading-relaxed">
                    <div>
                        <h3 class="text-2xl font-semibold text-gray-700 mb-4">El Problema de los Datos y la Física</h3>
                        <p>Las redes neuronales convencionales son excelentes para encontrar patrones en grandes conjuntos de datos, pero no tienen un conocimiento inherente de las leyes físicas. Esto significa que pueden producir resultados que, aunque se ajusten a los datos de entrenamiento, violen principios fundamentales como la conservación de la energía. Para aplicaciones científicas, esto es inaceptable.</p>
                    </div>
                    <div class="bg-blue-50 p-8 rounded-lg border-l-4 border-blue-500">
                        <h3 class="text-2xl font-semibold text-blue-800 mb-4">La Solución: Incluir la Ecuación en la Pérdida</h3>
                        <p class="text-blue-700">La idea central de una PINN es simple pero poderosa: si queremos que una red neuronal respete una ley física, debemos penalizarla cada vez que la viole. Esto se logra incorporando el residuo de la ecuación diferencial directamente en la función de pérdida. La red no solo intenta minimizar el error con los datos conocidos (condiciones iniciales/de contorno), sino que también se esfuerza por hacer que el residuo de la EDP sea cero en todo el dominio.</p>
                        <p class="mt-4 text-blue-700">Así, la red aprende a "descubrir" la solución que satisface tanto los datos como la física subyacente, actuando como un aproximador de funciones universal y, al mismo tiempo, como un solucionador de EDPs.</p>
                    </div>
                    <div>
                         <h3 class="text-2xl font-semibold text-gray-700 mb-4">Ventajas sobre los Métodos Clásicos</h3>
                        <p>A diferencia de los métodos de diferencias finitas o elementos finitos, las PINNs no requieren una malla. Operan en un dominio continuo y calculan derivadas mediante diferenciación automática, una técnica mucho más precisa que las aproximaciones numéricas. Esto las hace increíblemente flexibles para manejar geometrías complejas y problemas de alta dimensionalidad, abriendo la puerta a la solución de problemas que antes se consideraban intratables.</p>
                    </div>
                </div>
            </section>

            <section id="derivacion" class="section-card p-12">
                <h2 class="text-4xl font-bold text-gray-800 mb-8 text-center">Derivación de la Ecuación NLS</h2>
                <div class="space-y-8 max-w-4xl mx-auto">
                    <div class="equation-card p-8">
                        <h3 class="text-2xl font-semibold text-gray-700 mb-6">Separación en Partes Real e Imaginaria</h3>
                        <div class="space-y-6 text-lg text-gray-700 leading-relaxed">
                            <p>La red neuronal predecirá las partes real u(x,t) e imaginaria v(x,t) de la solución compleja h(x,t). Para ello, descomponemos la NLS en un sistema de dos ecuaciones diferenciales parciales (EDPs) reales acopladas.</p>
                            <p>Partimos de la forma compleja:</p>
                            <div class="text-center text-xl my-4 p-4 bg-gray-100 rounded-md">$$i h_t + \frac{1}{2} h_{xx} + |h|^2 h = 0$$</div>
                            <p>Definimos h(x,t) = u(x,t) + i v(x,t), donde u y v son funciones reales. Sus derivadas son:</p>
                            <div class="text-center text-xl my-4">
                                $$ h_t = u_t + i v_t \quad , \quad h_{xx} = u_{xx} + i v_{xx} $$
                            </div>
                            <p>El término no lineal se convierte en:</p>
                            <div class="text-center text-xl my-4">
                                $$ |h|^2 h = (u^2 + v^2)(u + i v) = (u^2 + v^2)u + i (u^2 + v^2)v $$
                            </div>
                            <p>Sustituyendo en la NLS y agrupando términos reales e imaginarios, obtenemos:</p>
                            <div class="text-center text-xl my-4">
                                $$ \left[ -v_t + \frac{1}{2} u_{xx} + (u^2 + v^2)u \right] + i \left[ u_t + \frac{1}{2} v_{xx} + (u^2 + v^2)v \right] = 0 $$
                            </div>
                            <p>Para que la ecuación se cumpla, tanto la parte real como la imaginaria deben ser cero. Esto nos da el sistema de EDPs que la PINN debe aprender:</p>
                            <div class="bg-blue-50 p-6 rounded-lg mt-4">
                                <div class="text-center text-xl space-y-4">
                                    <div class="font-semibold text-blue-800">Sistema de EDPs Acopladas</div>
                                    <div>
                                        $$\begin{cases}
                                        u_t = -\frac{1}{2} v_{xx} - (u^2 + v^2)v \\
                                        v_t = \frac{1}{2} u_{xx} + (u^2 + v^2)u
                                        \end{cases}$$
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            
            <section id="soluciones" class="section-card p-12">
                <h2 class="text-4xl font-bold text-gray-800 mb-8 text-center">Soluciones Analíticas Exactas</h2>
                 <p class="text-lg text-gray-600 text-center max-w-4xl mx-auto mb-8">
                        Para validar nuestro método PINN, utilizamos soluciones analíticas conocidas para diferentes 
                        números de solitones. Estas soluciones nos permiten comparar cuantitativamente la precisión 
                        de nuestra red neuronal.
                    </p>
                <div class="grid md:grid-cols-2 gap-8">
                     <div class="equation-card p-6">
                        <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">Solución para N=1 (Solitón Individual)</h3>
                        <div class="text-center text-lg mb-4">
                            $$h(x,t) = \exp(-it/2) \cdot \text{sech}(x)$$
                        </div>
                        <p class="text-gray-600 text-sm text-center">
                            Representa un solitón fundamental que mantiene su forma mientras se propaga.
                        </p>
                    </div>
                    <div class="equation-card p-6">
                        <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">Solución para N=2 (Dos Solitones)</h3>
                        <div class="text-center text-lg mb-4">
                            $$h(x,t) = 4\exp(-it/2) \frac{\cosh(3x) + 3\exp(-4it)\cosh(x)}{\cosh(4x) + 4\cosh(2x) + 3\cos(4t)}$$
                        </div>
                        <p class="text-gray-600 text-sm text-center">
                            Describe la interacción compleja entre dos solitones.
                        </p>
                    </div>
                </div>
            </section>

            <section id="visualizaciones" class="section-card p-12">
                <h2 class="text-4xl font-bold text-gray-800 mb-8 text-center">Visualización de Soluciones</h2>
                <div class="flex justify-center items-center mb-6 space-x-4">
                    <button id="btn-n1" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-md shadow-md hover:bg-blue-700 transition-all duration-300">
                        N=1 Solitón
                    </button>
                    <button id="btn-n2" class="px-6 py-2 bg-gray-200 text-gray-700 font-semibold rounded-md hover:bg-gray-300 transition-all duration-300">
                        N=2 Solitones
                    </button>
                </div>

                <div id="plots-n1">
                    <div class="grid md:grid-cols-2 gap-8">
                        <div>
                            <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">Módulo |h(x,t)|^2 (Superficie)</h3>
                            <div id="plot-n1-mod-3d" class="h-96"></div>
                        </div>
                        <div>
                            <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">Módulo |h(x,t)|^2 (Contorno)</h3>
                            <div id="plot-n1-mod-2d" class="h-96"></div>
                        </div>
                        <div>
                            <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">Parte Real u(x,t)</h3>
                            <div id="plot-n1-real-2d" class="h-96"></div>
                        </div>
                        <div>
                            <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">Parte Imaginaria v(x,t)</h3>
                            <div id="plot-n1-imag-2d" class="h-96"></div>
                        </div>
                    </div>
                </div>

                <div id="plots-n2" style="display: none;">
                    <div class="grid md:grid-cols-2 gap-8">
                         <div>
                            <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">Módulo $|h(x,t)|^2$ (Superficie)</h3>
                            <div id="plot-n2-mod-3d" class="h-96"></div>
                        </div>
                        <div>
                            <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">Módulo $|h(x,t)|^2$ (Contorno)</h3>
                            <div id="plot-n2-mod-2d" class="h-96"></div>
                        </div>
                        <div>
                           <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">Parte Real u(x,t)</h3>
                            <div id="plot-n2-real-2d" class="h-96"></div>
                        </div>
                        <div>
                           <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">Parte Imaginaria v(x,t)</h3>
                            <div id="plot-n2-imag-2d" class="h-96"></div>
                        </div>
                    </div>
                </div>
                
                <div class="mt-12 border-t pt-12">
                     <h3 class="text-2xl font-semibold text-gray-700 mb-4 text-center">Análisis Interactivo de Componentes</h3>
                    <div class="grid md:grid-cols-2 gap-8">
                        <div>
                            <label for="slider-t" class="block font-semibold text-gray-700 mb-2 text-center">
                                Perfil Espacial en t = <span id="t-value">0.00</span>
                            </label>
                            <input type="range" id="slider-t" min="0" max="99" value="0" class="w-full mb-4">
                            <div class="chart-container">
                                <canvas id="spatialChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <label for="slider-x" class="block font-semibold text-gray-700 mb-2 text-center">
                                Evolución Temporal en x = <span id="x-value">0.00</span>
                            </label>
                            <input type="range" id="slider-x" min="0" max="99" value="50" class="w-full mb-4">
                            <div class="chart-container">
                                <canvas id="temporalChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

            </section>
            
            <section id="pinn-teoria" class="section-card p-12">
                <h2 class="text-4xl font-bold text-gray-800 mb-8 text-center">Teoría de las PINNs</h2>
                
                <div class="grid md:grid-cols-2 gap-12">
                    <div class="space-y-8">
                        <div>
                            <h3 class="text-2xl font-semibold text-gray-700 mb-6">Arquitectura de la Red Neuronal</h3>
                            
                            <div class="bg-gradient-to-r from-blue-50 to-indigo-50 p-8 rounded-lg">
                                <div class="pinn-architecture mb-6">
                                    <div class="flex flex-col items-center">
                                        <div class="text-sm font-semibold text-gray-600 mb-2">Entrada</div>
                                        <div class="neuron-layer">
                                            <div class="neuron bg-green-400"></div>
                                            <div class="neuron bg-green-400"></div>
                                        </div>
                                        <div class="text-xs text-gray-500 mt-2">(x, t)</div>
                                    </div>
                                    
                                    <div class="connection"></div>
                                    
                                    <div class="flex flex-col items-center">
                                        <div class="text-sm font-semibold text-gray-600 mb-2">Ocultas</div>
                                        <div class="neuron-layer">
                                            <div class="neuron"></div>
                                            <div class="neuron"></div>
                                            <div class="neuron"></div>
                                            <div class="neuron"></div>
                                        </div>
                                        <div class="text-xs text-gray-500 mt-2">40 neuronas × 3</div>
                                    </div>
                                    
                                    <div class="connection"></div>
                                    
                                    <div class="flex flex-col items-center">
                                        <div class="text-sm font-semibold text-gray-600 mb-2">Salida</div>
                                        <div class="neuron-layer">
                                            <div class="neuron bg-red-400"></div>
                                            <div class="neuron bg-red-400"></div>
                                        </div>
                                        <div class="text-xs text-gray-500 mt-2">(u, v)</div>
                                    </div>
                                </div>
                                
                                <div class="text-center text-sm text-gray-600">
                                    <p class="font-semibold mb-2">Configuración: [2, 40, 40, 40, 2]</p>
                                    <p>Activación: tanh (capas ocultas), lineal (salida)</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-2xl font-semibold text-gray-700 mb-6">Función de Pérdida Compuesta</h3>
                        <div class="bg-amber-50 p-6 rounded-lg border-l-4 border-amber-500 mb-6">
                            <p class="text-amber-800 font-semibold mb-2">La pérdida híbrida combina:</p>
                            <ul class="list-disc list-inside text-amber-700 space-y-1">
                                <li>Datos de condiciones iniciales y de contorno</li>
                                <li>Residuos de las ecuaciones físicas</li>
                                <li>Restricciones de periodicidad</li>
                            </ul>
                        </div>
                        <div class="text-lg font-medium text-center text-gray-800 mb-6">
                                $$\mathcal{L}_{total} = \sum_{i=1}^{8} \mathcal{L}_i$$
                        </div>
                        <div class="space-y-3">
                            <div class="has-tooltip relative">
                                <div class="loss-term bg-blue-100 border border-blue-300">
                                    <span class="font-mono text-sm">MSE(u₀ - u₀ᵖʳᵉᵈ) + MSE(v₀ - v₀ᵖʳᵉᵈ)</span>
                                    <div class="tooltip absolute bottom-full left-1/2 transform -translate-x-1/2 bg-black text-white text-xs rounded py-2 px-3 mb-2">
                                        Pérdida en la condición inicial (t=0).
                                    </div>
                                </div>
                            </div>
                            <div class="has-tooltip relative">
                                <div class="loss-term bg-green-100 border border-green-300">
                                    <span class="font-mono text-sm">MSE(u_lb - u_ub) + MSE(v_lb - v_ub)</span>
                                    <div class="tooltip absolute bottom-full left-1/2 transform -translate-x-1/2 bg-black text-white text-xs rounded py-2 px-3 mb-2">
                                        Pérdida por periodicidad en los límites (x=-5, x=5).
                                    </div>
                                </div>
                            </div>
                            <div class="has-tooltip relative">
                                <div class="loss-term bg-purple-100 border border-purple-300">
                                    <span class="font-mono text-sm">MSE(∂u/∂x_lb - ∂u/∂x_ub) + MSE(∂v/∂x_lb - ∂v/∂x_ub)</span>
                                    <div class="tooltip absolute bottom-full left-1/2 transform -translate-x-1/2 bg-black text-white text-xs rounded py-2 px-3 mb-2">
                                        Periodicidad de la primera derivada espacial.
                                    </div>
                                </div>
                            </div>
                            <div class="has-tooltip relative">
                                <div class="loss-term bg-red-100 border border-red-300">
                                    <span class="font-mono text-sm">MSE(f_u) + MSE(f_v)</span>
                                    <div class="tooltip absolute bottom-full left-1/2 transform -translate-x-1/2 bg-black text-white text-xs rounded py-2 px-3 mb-2">
                                        Pérdida del residuo de la EDP, asegura que la física se cumpla.
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            
            <section id="implementacion" class="section-card p-12">
                <h2 class="text-4xl font-bold text-gray-800 mb-8 text-center">Claves de la Implementación</h2>
                <div class="max-w-4xl mx-auto space-y-12">

                    <div>
                        <h3 class="text-2xl font-semibold text-gray-700 mb-4">1. Inicialización de la Red (`initialize_NN`)</h3>
                        <p class="text-gray-600 mb-4 leading-relaxed">
                           <b>¿Qué hace?</b> Esta función es el constructor de la red. Define la estructura de la red neuronal creando los pesos (matrices `W`) y sesgos (vectores `b`) para cada capa. La dimensión de estas matrices y vectores está determinada por el arreglo `layers` (ej. [2, 40, 40, 2]).
                        </p>
                        <p class="text-gray-600 mb-4 leading-relaxed">
                           <b>¿Por qué es importante?</b> Una inicialización adecuada es crucial para un entrenamiento exitoso. Este código utiliza la <b>inicialización Xavier (o Glorot)</b>, que ajusta la escala de los pesos iniciales basándose en el número de neuronas de entrada y salida de una capa. Esto ayuda a prevenir que las señales (gradientes) se desvanezcan o exploten a medida que se propagan por la red, permitiendo un aprendizaje más rápido y estable.
                        </p>
                    </div>

                    <div>
                        <h3 class="text-2xl font-semibold text-gray-700 mb-4">2. Flujo de la Red y Entradas/Salidas</h3>
                         <p class="text-gray-600 mb-4 leading-relaxed">
                           <b>¿Qué le damos como input?</b> La red toma como entrada un tensor de coordenadas `[x, t]` de forma `(N, 2)`, donde `N` es el número de puntos. Antes de procesarlos, estos valores se normalizan al rango `[-1, 1]`. Esta normalización es estándar para redes que usan funciones de activación como la tangente hiperbólica (`tanh`), ya que asegura que las entradas caigan en la región donde la función tiene un gradiente significativo.
                        </p>
                        <p class="text-gray-600 mb-4 leading-relaxed">
                           <b>¿Qué nos da como output?</b> La red produce un tensor de salida de la forma `(N, 2)`, donde cada fila corresponde a la predicción `[u(x,t), v(x,t)]` para el punto de entrada `[x, t]` correspondiente. Estas son las aproximaciones de la parte real e imaginaria de la solución.
                        </p>
                    </div>
                    
                    <div>
                        <h3 class="text-2xl font-semibold text-gray-700 mb-4">3. Función de Pérdida (`loss`)</h3>
                         <p class="text-gray-600 mb-4 leading-relaxed">
                           <b>¿Qué es exactamente?</b> El parámetro `loss` no es solo un número; es el motor del aprendizaje. Es una función matemática que cuantifica qué tan "mal" está funcionando la red. El objetivo del entrenamiento es encontrar el conjunto de pesos y sesgos que minimicen este valor. En una PINN, la pérdida es una suma ponderada de varios errores:
                        </p>
                         <ul class="list-disc list-inside text-gray-600 space-y-2 mb-4">
                             <li><b>Pérdida de Datos:</b> El error entre las predicciones de la red y los valores conocidos (condiciones iniciales y de contorno).</li>
                             <li><b>Pérdida Física:</b> El residuo de la EDP. Si la solución predicha es correcta, al sustituirla en la ecuación, el resultado debería ser cero. La pérdida física mide qué tan lejos está de ser cero.</li>
                         </ul>
                         <p class="text-gray-600 leading-relaxed">
                            El optimizador (como Adam) utiliza el gradiente de esta función de pérdida para ajustar los pesos de la red en la dirección que reduzca el error total.
                         </p>
                    </div>

                    <div>
                        <h3 class="text-2xl font-semibold text-gray-700 mb-4">4. Inferencia (`predict`)</h3>
                        <p class="text-gray-600 mb-4 leading-relaxed">
                            <b>¿Qué hace exactamente?</b> A diferencia del entrenamiento, que busca ajustar los pesos, la función `predict` se utiliza <b>después</b> de que la red ha sido entrenada. Su propósito es tomar un conjunto de puntos `(x, t)` (generalmente una malla fina que cubre todo el dominio) y usar los pesos ya optimizados para generar la solución `u(x,t)` y `v(x,t)` en esos puntos. No realiza ninguna actualización de los parámetros de la red; simplemente evalúa el modelo final para la visualización y el análisis.
                        </p>
                    </div>
                </div>
                 <div class="mt-12 border-t pt-12">
                    <h2 class="text-4xl font-bold text-gray-800 mb-8 text-center">Implementación Detallada</h2>
                    <div class="space-y-8">
                        <div class="grid md:grid-cols-3 gap-8">
                            <div class="equation-card p-6">
                                <h3 class="text-lg font-semibold text-gray-700 mb-4">1. Función predict()</h3>
                                <p class="text-gray-600 text-sm mb-4">
                                    Evalúa la red entrenada en puntos de prueba, devolviendo predicciones y residuos.
                                </p>
                                <div class="code-block p-3 text-xs">
                                    <pre>
def predict(self, X_star):
    # Entrada: (x,t) puntos
    tf_dict = {
        self.x0_tf: X_star[:, 0:1], 
        self.t0_tf: X_star[:, 1:2]
    }
    
    # Predecir u, v
    u_star = self.sess.run(
        self.u0_pred, tf_dict)
    v_star = self.sess.run(
        self.v0_pred, tf_dict)
    
    # Evaluar residuos
    tf_dict = {
        self.x_f_tf: X_star[:, 0:1],
        self.t_f_tf: X_star[:, 1:2]
    }
    f_u_star = self.sess.run(
        self.f_u_pred, tf_dict)
    f_v_star = self.sess.run(
        self.f_v_pred, tf_dict)
    
    return u_star, v_star, f_u_star, f_v_star</pre>
                                </div>
                            </div>
                            
                            <div class="equation-card p-6">
                                <h3 class="text-lg font-semibold text-gray-700 mb-4">2. Inicialización de la Red</h3>
                                <p class="text-gray-600 text-sm mb-4">
                                    Configura pesos y biases con inicialización Xavier para estabilidad.
                                </p>
                                <div class="code-block p-3 text-xs">
                                    <pre>
def initialize_NN(self, layers):
    weights = []
    biases = []
    num_layers = len(layers)
    
    for l in range(0, num_layers - 1):
        W = tf.Variable(
            tf.random_normal(
                [layers[l], layers[l + 1]], 
                stddev=np.sqrt(1/layers[l])
            ),
            dtype=tf.float32
        )
        
        b = tf.Variable(
            tf.random_normal(
                [1, layers[l + 1]]
            ), 
            dtype=tf.float32
        )
        
        weights.append(W)
        biases.append(b)
    
    return weights, biases</pre>
                                </div>
                            </div>
                            
                            <div class="equation-card p-6">
                                <h3 class="text-lg font-semibold text-gray-700 mb-4">3. Red Neuronal</h3>
                                <p class="text-gray-600 text-sm mb-4">
                                    Forward pass con normalización de entrada y activación tanh.
                                </p>
                                <div class="code-block p-3 text-xs">
                                    <pre>
def neural_net(self, X, weights, biases):
    num_layers = len(weights) + 1
    
    # Normalización [-1, 1]
    H = 2.0 * (X - self.lb) / (self.ub - self.lb) - 1.0
    
    # Forward pass
    for l in range(0, num_layers - 2):
        W = weights[l]
        b = biases[l]
        H = tf.tanh(tf.add(tf.matmul(H, W), b))
    
    # Capa de salida (sin activación)
    W = weights[-1]
    b = biases[-1]
    Y = tf.add(tf.matmul(H, W), b)
    
    return Y</pre>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-gradient-to-r from-indigo-50 to-blue-50 p-8 rounded-lg">
                            <h3 class="text-2xl font-semibold text-gray-700 mb-6 text-center">Flujo de Entrenamiento</h3>
                            <div class="grid md:grid-cols-4 gap-6 text-center">
                                <div class="bg-white p-4 rounded-lg shadow">
                                    <div class="w-12 h-12 bg-blue-500 text-white rounded-full flex items-center justify-center mx-auto mb-3 font-bold">1</div>
                                    <h4 class="font-semibold text-gray-700 mb-2">Preparación de Datos</h4>
                                    <p class="text-sm text-gray-600">Generación de puntos de colocación y condiciones de contorno</p>
                                </div>
                                <div class="bg-white p-4 rounded-lg shadow">
                                    <div class="w-12 h-12 bg-green-500 text-white rounded-full flex items-center justify-center mx-auto mb-3 font-bold">2</div>
                                    <h4 class="font-semibold text-gray-700 mb-2">Optimización Adam</h4>
                                    <p class="text-sm text-gray-600">Entrenamiento inicial con 10,000 iteraciones</p>
                                </div>
                                <div class="bg-white p-4 rounded-lg shadow">
                                    <div class="w-12 h-12 bg-purple-500 text-white rounded-full flex items-center justify-center mx-auto mb-3 font-bold">3</div>
                                    <h4 class="font-semibold text-gray-700 mb-2">Refinamiento L-BFGS-B</h4>
                                    <p class="text-sm text-gray-600">Optimización de segundo orden para convergencia fina</p>
                                </div>
                                <div class="bg-white p-4 rounded-lg shadow">
                                    <div class="w-12 h-12 bg-red-500 text-white rounded-full flex items-center justify-center mx-auto mb-3 font-bold">4</div>
                                    <h4 class="font-semibold text-gray-700 mb-2">Evaluación</h4>
                                    <p class="text-sm text-gray-600">Cálculo de errores relativos vs. solución exacta</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            
            <section id="resultados" class="section-card p-12">
                <h2 class="text-4xl font-bold text-gray-800 mb-8 text-center">Resultados y Análisis</h2>
                <div class="grid md:grid-cols-2 gap-12">
                    <div class="space-y-6">
                        <h3 class="text-2xl font-semibold text-gray-700">Métricas de Rendimiento</h3>
                        
                        <div class="bg-green-50 p-6 rounded-lg border-l-4 border-green-500">
                            <h4 class="font-semibold text-green-800 mb-3">Error Relativo $L_2$</h4>
                            <div class="space-y-2">
                                <div class="flex justify-between">
                                    <span class="text-green-700">Error en $u(x,t)$:</span>
                                    <span class="font-mono text-green-800">8.75e-03 (TF1), 2.52e-03 (TF2), 1.01e-02 (PyTorch)</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-green-700">Error en $v(x,t)$:</span>
                                    <span class="font-mono text-green-800">1.37e-02 (TF1), 3.40e-03 (TF2), 1.53e-02 (PyTorch)</span>
                                </div>
                                <div class="flex justify-between font-semibold">
                                    <span class="text-green-700">Error en $|h(x,t)|$:</span>
                                    <span class="font-mono text-green-800">2.78e-03 (TF1), 1.45e-03 (TF2), 3.01e-03 (PyTorch)</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-blue-50 p-6 rounded-lg border-l-4 border-blue-500">
                            <h4 class="font-semibold text-blue-800 mb-3">Ventajas del Método</h4>
                            <ul class="list-disc list-inside text-blue-700 space-y-1">
                                <li>No requiere discretización espacial o temporal (sin malla).</li>
                                <li>Incorporación automática de leyes de conservación.</li>
                                <li>Capacidad de manejar geometrías complejas.</li>
                                <li>Robustez ante ruido en los datos.</li>
                                <li>Flexibilidad para resolver problemas inversos.</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="space-y-6">
                        <h3 class="text-2xl font-semibold text-gray-700">Comparación con Métodos Tradicionales</h3>
                        
                        <div class="overflow-hidden rounded-lg border border-gray-200">
                            <table class="w-full">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th class="px-4 py-3 text-left font-semibold text-gray-700">Método</th>
                                        <th class="px-4 py-3 text-left font-semibold text-gray-700">Precisión</th>
                                        <th class="px-4 py-3 text-left font-semibold text-gray-700">Flexibilidad</th>
                                    </tr>
                                </thead>
                                <tbody class="divide-y divide-gray-200">
                                    <tr>
                                        <td class="px-4 py-3 font-medium">Diferencias Finitas</td>
                                        <td class="px-4 py-3 text-yellow-600">Media</td>
                                        <td class="px-4 py-3 text-red-600">Baja (dependiente de malla)</td>
                                    </tr>
                                     <tr>
                                        <td class="px-4 py-3 font-medium">Elementos Finitos</td>
                                        <td class="px-4 py-3 text-green-600">Alta</td>
                                        <td class="px-4 py-3 text-yellow-600">Media</td>
                                    </tr>
                                    <tr class="bg-blue-50">
                                        <td class="px-4 py-3 font-medium">PINNs</td>
                                        <td class="px-4 py-3 text-green-600">Alta</td>
                                        <td class="px-4 py-3 text-green-600">Muy Alta (sin malla)</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        
                        <div class="bg-amber-50 p-6 rounded-lg border-l-4 border-amber-500">
                            <h4 class="font-semibold text-amber-800 mb-3">Limitaciones Actuales</h4>
                            <ul class="list-disc list-inside text-amber-700 space-y-1">
                                <li>Tiempo de entrenamiento potencialmente elevado.</li>
                                <li>Sensibilidad a la arquitectura y los hiperparámetros.</li>
                                <li>Dificultad con problemas altamente no lineales o caóticos.</li>
                                <li>Necesidad de expertise en ML y física del problema.</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>        <!-- Section for Framework Comparison -->
        <section id="comparacion" class="my-12">
            <div class="container mx-auto px-4">
                <div class="section-card p-8 rounded-xl shadow-2xl space-y-8">
                    <h2 class="text-3xl font-bold text-gray-800 text-center">Comparativa de Frameworks</h2>
                    <p class="text-lg text-gray-700 max-w-3xl mx-auto text-center">
                        Para evaluar la eficiencia y precisión de las Redes Neuronales Informadas por la Física (PINNs) en la resolución de la Ecuación de Schrödinger No Lineal, se implementó el modelo con la <strong>misma arquitectura [2, 40, 40, 40, 2]</strong> en cuatro configuraciones diferentes: TensorFlow 1, TensorFlow 2, PyTorch y PyTorch Optimizado. A continuación, se presentan los resultados obtenidos.
                    </p>
        
                    <div class="grid grid-cols-1 lg:grid-cols-5 gap-8 items-center">
                        <!-- GIF Animation -->
                        <div class="lg:col-span-2">
                            <img src="nlse_evolution.gif" alt="Evolución de la solución NLSE" class="rounded-lg shadow-lg w-full">
                            <p class="text-center text-sm mt-2 text-gray-600">Evolución temporal de la magnitud de la solución $|h(t,x)|$ predicha por la PINN.</p>
                        </div>
        
                        <!-- Results Table -->
                        <div class="lg:col-span-3">
                            <h3 class="text-2xl font-semibold text-gray-800 mb-4">Resultados del Entrenamiento</h3>
                            <div class="overflow-x-auto">
                                <table class="min-w-full bg-white rounded-lg shadow">
                                    <thead class="bg-blue-500 text-white">
                                        <tr>
                                            <th class="text-left py-3 px-4 uppercase font-semibold text-sm">Framework</th>
                                            <th class="text-left py-3 px-4 uppercase font-semibold text-sm">Error u</th>
                                            <th class="text-left py-3 px-4 uppercase font-semibold text-sm">Error v</th>
                                            <th class="text-left py-3 px-4 uppercase font-semibold text-sm">Error h</th>
                                            <th class="text-left py-3 px-4 uppercase font-semibold text-sm">Tiempo (s)</th>
                                        </tr>
                                    </thead>
                                    <tbody class="text-gray-700">
                                        <tr class="border-b">
                                            <td class="text-left py-3 px-4 font-medium">TensorFlow 1</td>
                                            <td class="text-left py-3 px-4">7.20e-03</td>
                                            <td class="text-left py-3 px-4">1.14e-02</td>
                                            <td class="text-left py-3 px-4">2.31e-03</td>
                                            <td class="text-left py-3 px-4">362.24</td>
                                        </tr>                                        <tr class="bg-gray-50 border-b">
                                            <td class="text-left py-3 px-4 font-medium">TensorFlow 2</td>
                                            <td class="text-left py-3 px-4">3.10e-02</td>
                                            <td class="text-left py-3 px-4">5.06e-02</td>
                                            <td class="text-left py-3 px-4">7.72e-03</td>
                                            <td class="text-left py-3 px-4">484.16</td>
                                        </tr>
                                        <tr class="border-b">
                                            <td class="text-left py-3 px-4 font-medium">PyTorch</td>
                                            <td class="text-left py-3 px-4">1.01e-02</td>
                                            <td class="text-left py-3 px-4">1.53e-02</td>
                                            <td class="text-left py-3 px-4">3.01e-03</td>
                                            <td class="text-left py-3 px-4">369.10</td>
                                        </tr>
                                        <tr class="bg-green-50 border-b border-green-200">
                                            <td class="text-left py-3 px-4 font-medium text-green-800">PyTorch Optimizado</td>
                                            <td class="text-left py-3 px-4 text-green-700">1.02e-02</td>
                                            <td class="text-left py-3 px-4 text-green-700">1.58e-02</td>
                                            <td class="text-left py-3 px-4 text-green-700">3.15e-03</td>
                                            <td class="text-left py-3 px-4 font-bold text-green-700">280.87</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                             <p class="mt-4 text-gray-600">
                                <strong>Análisis:</strong> Todas las implementaciones utilizaron la misma arquitectura de red neuronal [2, 40, 40, 40, 2]. TensorFlow 1 logró la mejor precisión con el error h más bajo (2.31e-03) en 362.24 segundos. PyTorch Optimizado ofreció el mejor balance entre velocidad y precisión, completando el entrenamiento en solo 280.87 segundos con errores comparables. TensorFlow 2 fue el más lento y presentó errores más altos. PyTorch estándar mostró un rendimiento intermedio tanto en tiempo como en precisión.
                            </p>
                        </div>
                    </div>
        
                    <!-- Chart for Visual Comparison -->
                    <div class="mt-8 pt-8 border-t border-gray-300">
                        <h3 class="text-2xl font-semibold text-gray-800 mb-4 text-center">Gráfica Comparativa de Métricas</h3>
                        <div class="bg-white/50 p-4 rounded-lg">
                            <canvas id="comparisonChart"></canvas>
                        </div>
                    </div>                </div>
            </div>
        </section>        <!-- New Section: NLS 2-Soliton Interaction Results -->
        <section id="nls-2soliton" class="my-12">
            <div class="container mx-auto px-4">
                <div class="section-card p-8 rounded-xl shadow-2xl space-y-8">
                    <h2 class="text-3xl font-bold text-gray-800 text-center">Resultados: NLS con Interacción de 2 Solitones</h2>
                    <p class="text-lg text-gray-700 max-w-3xl mx-auto text-center">
                        Se implementó una PINN para resolver la ecuación de Schrödinger no lineal con interacción de dos solitones. 
                        La arquitectura utilizada fue <strong>[2, 80, 80, 80, 80, 2]</strong> (más profunda que la variante anterior) 
                        con 20,000 puntos de colocación para capturar la dinámica compleja de la interacción.
                    </p>

                    <div class="grid grid-cols-1 lg:grid-cols-5 gap-8 items-center">
                        <!-- Static Image -->
                        <div class="lg:col-span-2">
                            <img src="nls_evolution.gif" alt="Comparación exacta vs predicha para 2 solitones" class="rounded-lg shadow-lg w-full">
                            <p class="text-center text-sm mt-2 text-gray-600">
                                Comparación de la solución exacta (azul) y la predicción de la PINN (rojo punteado) para la interacción de dos solitones.
                            </p>
                        </div>

                        <!-- Results Table -->
                        <div class="lg:col-span-3">
                            <h3 class="text-2xl font-semibold text-gray-800 mb-4">Comparativa de Implementaciones</h3>
                            <div class="overflow-x-auto">
                                <table class="min-w-full bg-white rounded-lg shadow">
                                    <thead class="bg-purple-500 text-white">
                                        <tr>
                                            <th class="text-left py-3 px-4 uppercase font-semibold text-sm">Framework</th>
                                            <th class="text-left py-3 px-4 uppercase font-semibold text-sm">Error u</th>
                                            <th class="text-left py-3 px-4 uppercase font-semibold text-sm">Error v</th>
                                            <th class="text-left py-3 px-4 uppercase font-semibold text-sm">Error h</th>
                                            <th class="text-left py-3 px-4 uppercase font-semibold text-sm">Tiempo (s)</th>
                                        </tr>
                                    </thead>
                                    <tbody class="text-gray-700">
                                        <tr class="border-b hover:bg-gray-50">
                                            <td class="text-left py-3 px-4 font-medium">TensorFlow 1</td>
                                            <td class="text-left py-3 px-4">1.021e-02</td>
                                            <td class="text-left py-3 px-4">1.175e-02</td>
                                            <td class="text-left py-3 px-4 font-semibold text-green-600">7.299e-03</td>
                                            <td class="text-left py-3 px-4">1723.09</td>
                                        </tr>
                                        <tr class="border-b hover:bg-gray-50">
                                            <td class="text-left py-3 px-4 font-medium">PyTorch</td>
                                            <td class="text-left py-3 px-4">1.979e-02</td>
                                            <td class="text-left py-3 px-4">2.402e-02</td>
                                            <td class="text-left py-3 px-4">1.046e-02</td>
                                            <td class="text-left py-3 px-4">2565.47</td>
                                        </tr>
                                        <tr class="bg-green-50 border-b border-green-200 hover:bg-green-100">
                                            <td class="text-left py-3 px-4 font-medium text-green-800">PyTorch Optimizado</td>
                                            <td class="text-left py-3 px-4 text-green-700">1.259e-02</td>
                                            <td class="text-left py-3 px-4 text-green-700">1.415e-02</td>
                                            <td class="text-left py-3 px-4 text-green-700">9.215e-03</td>
                                            <td class="text-left py-3 px-4 font-bold text-green-700">561.31</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                            <p class="mt-4 text-gray-600">
                                <strong>Análisis:</strong> Para el problema de 2 solitones con arquitectura [2, 80, 80, 80, 80, 2], 
                                TensorFlow 1 logró la mejor precisión (error h: 7.299e-03) pero con el tiempo de entrenamiento más alto (1723s). 
                                <strong>PyTorch Optimizado</strong> ofreció el mejor balance, alcanzando errores competitivos (9.215e-03) en solo 561 segundos, 
                                3x más rápido que TensorFlow 1. PyTorch estándar fue el más lento (2565s) con errores intermedios.
                            </p>
                        </div>
                    </div>

                    <!-- Detailed Comparison Chart -->
                    <div class="mt-8 pt-8 border-t border-gray-300">
                        <h3 class="text-2xl font-semibold text-gray-800 mb-4 text-center">Gráfica Comparativa: 2 Solitones</h3>
                        <div class="bg-white/50 p-4 rounded-lg">
                            <canvas id="comparison2SolitonChart"></canvas>
                        </div>
                    </div>

                    <!-- Key Insights -->
                    <div class="grid md:grid-cols-3 gap-6 mt-8">
                        <div class="bg-blue-50 p-6 rounded-lg border-l-4 border-blue-500">
                            <h4 class="font-semibold text-blue-800 mb-3 flex items-center">
                                <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                                </svg>
                                Mejor Precisión
                            </h4>
                            <p class="text-blue-700">
                                <strong>TensorFlow 1:</strong> Error h de 7.299e-03, ideal cuando la precisión es crítica.
                            </p>
                        </div>
                        <div class="bg-green-50 p-6 rounded-lg border-l-4 border-green-500">
                            <h4 class="font-semibold text-green-800 mb-3 flex items-center">
                                <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"/>
                                </svg>
                                Mejor Velocidad
                            </h4>
                            <p class="text-green-700">
                                <strong>PyTorch Optimizado:</strong> 561 segundos, 3x más rápido que TensorFlow 1 con buena precisión.
                            </p>
                        </div>
                        <div class="bg-amber-50 p-6 rounded-lg border-l-4 border-amber-500">
                            <h4 class="font-semibold text-amber-800 mb-3 flex items-center">
                                <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M3 6a3 3 0 013-3h10a1 1 0 01.8 1.6L14.25 8l2.55 3.4A1 1 0 0116 13H6a1 1 0 00-1 1v3a1 1 0 11-2 0V6z" clip-rule="evenodd"/>
                                </svg>
                                Recomendación
                            </h4>
                            <p class="text-amber-700">
                                Para producción: <strong>PyTorch Optimizado</strong>. Para investigación de alta precisión: <strong>TensorFlow 1</strong>.
                            </p>
                        </div>
                    </div>                </div>
            </div>
        </section>

        <!-- New Section: Análisis Comparativo de Métodos para Periodicidad -->
        <section id="analisis-periodicidad" class="my-12">
            <div class="container mx-auto px-4">
                <div class="section-card p-8 rounded-xl shadow-2xl space-y-8">
                    <h2 class="text-3xl font-bold text-gray-800 text-center">Análisis Comparativo: Tres Métodos PINN para Periodicidad Temporal</h2>
                    
                    <p class="text-lg text-gray-700 max-w-4xl mx-auto text-center">
                        Se implementaron y compararon <strong>tres enfoques diferentes</strong> para manejar la periodicidad temporal 
                        en PINNs aplicados a la ecuación NLS con N=2 solitones sobre el periodo extendido <strong>[0, 2π]</strong>. 
                        Este análisis exhaustivo revela las fortalezas y limitaciones de cada método.
                    </p>

                    <!-- Los Tres Métodos -->
                    <div class="grid md:grid-cols-3 gap-6 mt-8">
                        <div class="bg-blue-50 p-6 rounded-lg border-l-4 border-blue-500">
                            <h3 class="text-xl font-semibold text-blue-800 mb-3">🌊 Método A: Fourier Features</h3>
                            <p class="text-blue-700 text-sm mb-3">
                                Codificación periódica del tiempo usando características de Fourier en la arquitectura de la red.
                            </p>
                            <ul class="text-blue-600 text-sm list-disc list-inside space-y-1">
                                <li>4 frecuencias de Fourier</li>
                                <li>Arquitectura: [2+8, 50, 50, 50, 50, 2]</li>
                                <li>50,000 puntos de colocación</li>
                            </ul>
                        </div>

                        <div class="bg-green-50 p-6 rounded-lg border-l-4 border-green-500">
                            <h3 class="text-xl font-semibold text-green-800 mb-3">🎯 Método B: Explicit Periodic Loss</h3>
                            <p class="text-green-700 text-sm mb-3">
                                Pérdida explícita que fuerza ψ(x,0) ≈ ψ(x,T) mediante un término adicional en la función de pérdida.
                            </p>
                            <ul class="text-green-600 text-sm list-disc list-inside space-y-1">
                                <li>λ_periodic = 10.0</li>
                                <li>Arquitectura: [2, 50, 50, 50, 50, 2]</li>
                                <li>50,000 puntos de colocación</li>
                            </ul>
                        </div>

                        <div class="bg-purple-50 p-6 rounded-lg border-l-4 border-purple-500">
                            <h3 class="text-xl font-semibold text-purple-800 mb-3">🔧 Método C: XPINN</h3>
                            <p class="text-purple-700 text-sm mb-3">
                                División del dominio temporal en subdominios con redes independientes y condiciones de interface.
                            </p>
                            <ul class="text-purple-600 text-sm list-disc list-inside space-y-1">
                                <li>4 subdominios temporales</li>
                                <li>Arquitectura: [2, 50, 50, 50, 2] × 4</li>
                                <li>12,500 puntos/subdominio</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Tabla Comparativa de Resultados -->
                    <div class="mt-12">
                        <h3 class="text-2xl font-semibold text-gray-800 mb-6 text-center">Resultados Cuantitativos</h3>
                        <div class="overflow-x-auto">
                            <table class="min-w-full bg-white rounded-lg shadow">
                                <thead class="bg-gradient-to-r from-blue-500 to-purple-500 text-white">
                                    <tr>
                                        <th class="text-left py-3 px-4 uppercase font-semibold text-sm">Método</th>
                                        <th class="text-center py-3 px-4 uppercase font-semibold text-sm">Error u (L2)</th>
                                        <th class="text-center py-3 px-4 uppercase font-semibold text-sm">Error v (L2)</th>
                                        <th class="text-center py-3 px-4 uppercase font-semibold text-sm">Error |ψ| (L2)</th>
                                        <th class="text-center py-3 px-4 uppercase font-semibold text-sm">Periodic u</th>
                                        <th class="text-center py-3 px-4 uppercase font-semibold text-sm">Periodic |ψ|</th>
                                        <th class="text-center py-3 px-4 uppercase font-semibold text-sm">Tiempo (min)</th>
                                    </tr>
                                </thead>
                                <tbody class="text-gray-700">
                                    <tr class="border-b hover:bg-blue-50">
                                        <td class="text-left py-3 px-4 font-medium">Método A (Fourier)</td>
                                        <td class="text-center py-3 px-4">0.495</td>
                                        <td class="text-center py-3 px-4">0.534</td>
                                        <td class="text-center py-3 px-4">0.401</td>
                                        <td class="text-center py-3 px-4 text-green-600 font-semibold">0.004</td>
                                        <td class="text-center py-3 px-4">0.006</td>
                                        <td class="text-center py-3 px-4 font-semibold">8.4</td>
                                    </tr>
                                    <tr class="bg-green-50 border-b border-green-200 hover:bg-green-100">
                                        <td class="text-left py-3 px-4 font-medium text-green-800">Método B (Loss) ⭐</td>
                                        <td class="text-center py-3 px-4">0.496</td>
                                        <td class="text-center py-3 px-4">0.535</td>
                                        <td class="text-center py-3 px-4">0.402</td>
                                        <td class="text-center py-3 px-4 text-green-600 font-semibold">0.005</td>
                                        <td class="text-center py-3 px-4 text-green-600 font-semibold">0.005</td>
                                        <td class="text-center py-3 px-4">11.0</td>
                                    </tr>
                                    <tr class="border-b hover:bg-purple-50">
                                        <td class="text-left py-3 px-4 font-medium">Método C (XPINN)</td>
                                        <td class="text-center py-3 px-4 text-red-600">0.659</td>
                                        <td class="text-center py-3 px-4 text-red-600">0.701</td>
                                        <td class="text-center py-3 px-4 text-red-600">0.542</td>
                                        <td class="text-center py-3 px-4 text-red-600">0.013</td>
                                        <td class="text-center py-3 px-4 text-red-600">0.079</td>
                                        <td class="text-center py-3 px-4 text-red-600">24.4</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="mt-4 text-gray-600 text-center text-sm">
                            ⭐ <strong>Método B (Explicit Periodic Loss)</strong> ofrece el mejor balance: 
                            periodicidad comparable a Fourier, simple de implementar, y tiempo razonable.
                        </p>
                    </div>

                    <!-- Gráficas Comparativas -->
                    <div class="mt-12">
                        <h3 class="text-2xl font-semibold text-gray-800 mb-6 text-center">Comparación Visual de Errores</h3>
                        <div class="bg-white/50 p-4 rounded-lg">
                            <canvas id="periodicityComparisonChart"></canvas>
                        </div>
                    </div>

                    <!-- Análisis de Periodicidad -->
                    <div class="mt-12 border-t pt-12">
                        <h3 class="text-2xl font-semibold text-gray-800 mb-6 text-center">Verificación de Periodicidad: t=0 vs t=2π</h3>
                        <p class="text-gray-700 mb-6 text-center max-w-3xl mx-auto">
                            Un criterio fundamental es que la solución predicha debe satisfacer <strong>ψ(x, 0) = ψ(x, 2π)</strong>. 
                            A continuación se muestra el error de periodicidad para cada método.
                        </p>
                        <div class="bg-white/50 p-4 rounded-lg">
                            <canvas id="periodicityErrorChart"></canvas>
                        </div>
                    </div>

                    <!-- Diagnóstico de Problemas -->
                    <div class="mt-12 bg-red-50 p-8 rounded-lg border-l-4 border-red-500">
                        <h3 class="text-2xl font-semibold text-red-800 mb-6">🔍 Diagnóstico: ¿Por qué Ningún Método Funcionó Bien?</h3>
                        <div class="space-y-6">
                            <div>
                                <h4 class="text-lg font-semibold text-red-700 mb-2">❌ Problema 1: Errores L2 Muy Altos (> 0.4)</h4>
                                <p class="text-red-600">
                                    Todos los métodos tienen errores relativos superiores al 40%, lo cual indica que <strong>no capturan 
                                    correctamente la solución</strong>. La ecuación NLS N=2 es extremadamente no lineal y requiere 
                                    arquitecturas más profundas.
                                </p>
                            </div>
                            <div>
                                <h4 class="text-lg font-semibold text-red-700 mb-2">❌ Problema 2: Periodicidad No Capturada</h4>
                                <p class="text-red-600">
                                    Aunque los errores de periodicidad son bajos (~0.5-1.3%), <strong>esto es engañoso</strong> porque 
                                    la solución base ya está muy lejos de la correcta. Una periodicidad "buena" sobre una solución 
                                    incorrecta no tiene valor.
                                </p>
                            </div>
                            <div>
                                <h4 class="text-lg font-semibold text-red-700 mb-2">❌ Problema 3: Causas Identificadas</h4>
                                <ul class="list-disc list-inside text-red-600 space-y-1 ml-4">
                                    <li>Redes poco profundas (4-5 capas de 50 neuronas)</li>
                                    <li>Fourier: Solo 4 frecuencias (insuficiente para [0, 2π])</li>
                                    <li>Loss: λ_periodic = 10 muy bajo (dominado por PDE)</li>
                                    <li>XPINN: Discontinuidades en interfaces</li>
                                    <li>Pocas épocas de convergencia (~30,000)</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- Propuestas de Mejora -->
                    <div class="mt-12 bg-green-50 p-8 rounded-lg border-l-4 border-green-500">
                        <h3 class="text-2xl font-semibold text-green-800 mb-6">💡 Propuestas de Mejora</h3>
                        
                        <div class="grid md:grid-cols-2 gap-6">
                            <!-- Propuesta 1: Método Híbrido -->
                            <div class="bg-white p-6 rounded-lg shadow">
                                <div class="flex items-center mb-3">
                                    <span class="bg-green-500 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold mr-3">1</span>
                                    <h4 class="text-lg font-semibold text-green-800">Método Híbrido (PRIORIDAD ALTA)</h4>
                                </div>
                                <p class="text-green-700 text-sm mb-3">
                                    Combinar Fourier Features + Explicit Periodic Loss:
                                </p>
                                <ul class="text-green-600 text-sm list-disc list-inside space-y-1">
                                    <li>10-12 frecuencias de Fourier (vs 4)</li>
                                    <li>λ_periodic = 200-500 (vs 10)</li>
                                    <li>Arquitectura: [26, 100, 100, 100, 100, 2]</li>
                                    <li>50,000+ puntos de colocación</li>
                                    <li>30,000 épocas Adam + 5,000 L-BFGS</li>
                                </ul>
                            </div>

                            <!-- Propuesta 2: Curriculum Learning -->
                            <div class="bg-white p-6 rounded-lg shadow">
                                <div class="flex items-center mb-3">
                                    <span class="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold mr-3">2</span>
                                    <h4 class="text-lg font-semibold text-blue-800">Curriculum Learning</h4>
                                </div>
                                <p class="text-blue-700 text-sm mb-3">
                                    Entrenar progresivamente en dominios crecientes:
                                </p>
                                <ul class="text-blue-600 text-sm list-disc list-inside space-y-1">
                                    <li>Fase 1: [0, π/2] → 5,000 épocas</li>
                                    <li>Fase 2: [0, π] → 5,000 épocas</li>
                                    <li>Fase 3: [0, 3π/2] → 5,000 épocas</li>
                                    <li>Fase 4: [0, 2π] → 10,000 épocas</li>
                                </ul>
                            </div>

                            <!-- Propuesta 3: Physics-Guided Sampling -->
                            <div class="bg-white p-6 rounded-lg shadow">
                                <div class="flex items-center mb-3">
                                    <span class="bg-purple-500 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold mr-3">3</span>
                                    <h4 class="text-lg font-semibold text-purple-800">Physics-Guided Sampling</h4>
                                </div>
                                <p class="text-purple-700 text-sm mb-3">
                                    Concentrar puntos donde la física es más compleja:
                                </p>
                                <ul class="text-purple-600 text-sm list-disc list-inside space-y-1">
                                    <li>Más puntos donde |ψ|² es grande</li>
                                    <li>Muestreo adaptativo en colisiones</li>
                                    <li>30% guiado por energía, 70% uniforme</li>
                                </ul>
                            </div>

                            <!-- Propuesta 4: Adaptive Weighting -->
                            <div class="bg-white p-6 rounded-lg shadow">
                                <div class="flex items-center mb-3">
                                    <span class="bg-amber-500 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold mr-3">4</span>
                                    <h4 class="text-lg font-semibold text-amber-800">Adaptive Weighting</h4>
                                </div>
                                <p class="text-amber-700 text-sm mb-3">
                                    Ponderación dinámica de pérdidas:
                                </p>
                                <ul class="text-amber-600 text-sm list-disc list-inside space-y-1">
                                    <li>Identificar regiones con error alto</li>
                                    <li>Aumentar peso de pérdida ahí</li>
                                    <li>Actualizar pesos cada 500 épocas</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- Ranking Final -->
                    <div class="mt-12 bg-gradient-to-r from-yellow-50 to-amber-50 p-8 rounded-lg border-2 border-amber-300">
                        <h3 class="text-2xl font-semibold text-amber-800 mb-6 text-center">🏆 Ranking Final de Métodos</h3>
                        <div class="space-y-4">
                            <div class="flex items-center bg-white p-4 rounded-lg shadow">
                                <span class="text-4xl mr-4">🥈</span>
                                <div class="flex-1">
                                    <h4 class="text-lg font-semibold text-gray-800">2º Lugar: Método B (Explicit Periodic Loss)</h4>
                                    <p class="text-gray-600 text-sm">
                                        <strong>Mejor periodicidad</strong> (0.005), <strong>simple</strong> de implementar, 
                                        <strong>base recomendada</strong> para mejoras futuras. Tiempo razonable: 11 min.
                                    </p>
                                </div>
                            </div>
                            <div class="flex items-center bg-white p-4 rounded-lg shadow">
                                <span class="text-4xl mr-4">🥉</span>
                                <div class="flex-1">
                                    <h4 class="text-lg font-semibold text-gray-800">3º Lugar: Método A (Fourier Features)</h4>
                                    <p class="text-gray-600 text-sm">
                                        <strong>Concepto elegante</strong>, más rápido (8.4 min), pero necesita más frecuencias 
                                        para capturar [0, 2π]. Potencial alto con mejoras.
                                    </p>
                                </div>
                            </div>
                            <div class="flex items-center bg-gray-100 p-4 rounded-lg shadow">
                                <span class="text-4xl mr-4">❌</span>
                                <div class="flex-1">
                                    <h4 class="text-lg font-semibold text-gray-800">Último: Método C (XPINN)</h4>
                                    <p class="text-gray-600 text-sm">
                                        <strong>Peor error</strong> (0.701), <strong>lento</strong> (24 min), 
                                        <strong>discontinuidades</strong> visibles. No justifica la complejidad adicional.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Conclusiones -->
                    <div class="mt-12 border-t pt-8">
                        <h3 class="text-2xl font-semibold text-gray-800 mb-6 text-center">📝 Conclusiones del Análisis Comparativo</h3>
                        <div class="max-w-4xl mx-auto space-y-4 text-gray-700">
                            <p class="leading-relaxed">
                                <strong>1. Ningún método funcionó satisfactoriamente</strong> para el problema NLS N=2 periódico en [0, 2π]. 
                                Los errores L2 superiores al 40% indican que las soluciones predichas están muy lejos de las exactas.
                            </p>
                            <p class="leading-relaxed">
                                <strong>2. El Método B (Explicit Periodic Loss) es la mejor base</strong> para futuras mejoras debido a su 
                                simplicidad, buen control de periodicidad, y tiempo de entrenamiento razonable.
                            </p>
                            <p class="leading-relaxed">
                                <strong>3. El problema es extremadamente difícil:</strong> La ecuación NLS N=2 es altamente no lineal con 
                                interacciones complejas entre solitones, cambios de fase rápidos, y múltiples escalas temporales.
                            </p>
                            <p class="leading-relaxed">
                                <strong>4. Próximo paso recomendado:</strong> Implementar el <strong>Método Híbrido</strong> que combine 
                                Fourier Features (12 frecuencias) + Explicit Periodic Loss (λ=300) + Curriculum Learning + Arquitectura 
                                más profunda [26, 100, 100, 100, 100, 2].
                            </p>
                        </div>
                    </div>

                </div>
            </div>
        </section>

             <section id="conclusion" class="section-card p-12">
                <h2 class="text-4xl font-bold text-gray-800 mb-8 text-center">Conclusión</h2>
                <div class="max-w-4xl mx-auto text-lg text-gray-600 space-y-6 leading-relaxed">
                    
                    <p>
                        Los resultados validan a las PINNs como una alternativa poderosa y flexible a los métodos numéricos tradicionales, con el potencial de acelerar drásticamente las simulaciones científicas y abordar problemas que antes eran computacionalmente prohibitivos. Este enfoque abre nuevas vías no solo para la simulación directa, sino también para el descubrimiento de modelos y la asimilación de datos en sistemas físicos complejos.
                    </p>
                     <p class="font-semibold text-gray-700">
                        El futuro de la simulación científica puede no depender únicamente de la fuerza bruta computacional, sino de la sinergia inteligente entre los datos, los algoritmos de aprendizaje y las leyes fundamentales de la física.
                    </p>
                </div>
            </section>
            
            <section id="codigo" class="section-card p-12">
                <h2 class="text-4xl font-bold text-gray-800 mb-8 text-center">Código para Generar Archivo .mat</h2>
                <div class="code-block p-4 text-sm max-w-4xl mx-auto">
                    <pre>
import numpy as np
import scipy.io as sio
import matplotlib.pyplot as plt

def nonlinear_schrodinger_solution(N=1):
    """
    Genera la solución exacta de la ecuación de Schrödinger no lineal
    para N=1 (solitón fundamental) o N=2 (dos solitones)
    en el dominio x ∈ [-5, 5], t ∈ [0, π/2]
    """
    # Parámetros del dominio
    x_min, x_max = -5.0, 5.0
    t_min, t_max = 0.0, np.pi/2
    
    # Número de puntos en cada dimensión
    Nx = 256  # Puntos en espacio
    Nt = 100  # Puntos en tiempo
    
    # Crear mallas
    x_values = np.linspace(x_min, x_max, Nx)
    t_values = np.linspace(t_min, t_max, Nt)
    X, T = np.meshgrid(x_values, t_values)
    
    if N == 1:
        # Solución para N=1 (solitón fundamental)
        def exact_solution(x, t):
            """
            Solución exacta del solitón de la NLSE para N=1:
            ψ(x,t) = A * sech(A*(x - x0)) * exp(i*(A^2/2)*t)
            """
            A = 1.0    # Amplitud
            x0 = 0.0   # Centro del solitón
            
            sech_term = A / np.cosh(A * (x - x0))
            phase = 0.5 * A * A * t
            
            real_part = sech_term * np.cos(phase)
            imag_part = sech_term * np.sin(phase)
            
            return real_part + 1j*imag_part
        
        description = 'Solución NLSE N=1: ψ(x,t) = sech(x) * exp(i*t/2)'
        
    elif N == 2:
        # Solución para N=2 (dos solitones)
        def exact_solution(x, t):
            """
            Solución exacta para dos solitones de la NLSE
            ψ(x,t) = [4(cosh(3x) + 3e^(4it)cosh(x)) * e^(it/2)] / 
                     [cosh(4x) + 4cosh(2x) + 3cos(4t)]
            """
            numerator = 4 * (np.cosh(3*x) + 3 * np.exp(4j*t) * np.cosh(x)) * np.exp(0.5j*t)
            denominator = np.cosh(4*x) + 4 * np.cosh(2*x) + 3 * np.cos(4*t)
            
            return numerator / denominator
        
        description = 'Solución NLSE N=2: Dos solitones interactuando'
    
    else:
        raise ValueError("N debe ser 1 o 2")
    
    # Calcular la solución en toda la malla
    q_values = np.zeros((Nx, Nt), dtype=complex)
    
    for i, t in enumerate(t_values):
        for j, x in enumerate(x_values):
            q_values[j, i] = exact_solution(x, t)
    
    # Crear diccionario con los datos
    data = {
        'x_values': x_values.reshape(-1, 1),
        't_values': t_values.reshape(-1, 1),
        'q_values': q_values,
        'description': description,
        'N': N,
        'domain': {
            'x_min': x_min,
            'x_max': x_max,
            't_min': t_min,
            't_max': t_max
        }
    }
    
    # Guardar en archivo .mat
    filename = f'NLS_N{N}.mat'
    sio.savemat(filename, data)
    
    print(f"Archivo '{filename}' creado exitosamente")
    print(f"N = {N}")
    print(f"Dimensiones: x={Nx} puntos, t={Nt} puntos")
    print(f"Dominio: x ∈ [{x_min}, {x_max}], t ∈ [{t_min}, {t_max}]")
    
    # Visualizar para verificar
    plt.figure(figsize=(15, 5))
    
    # Parte real
    plt.subplot(1, 3, 1)
    im1 = plt.imshow(np.real(q_values.T), extent=[x_min, x_max, t_min, t_max], 
                    aspect='auto', origin='lower', cmap='RdBu_r')
    plt.colorbar(im1, label='Re(ψ)')
    plt.xlabel('Espacio (x)')
    plt.ylabel('Tiempo (t)')
    plt.title(f'Parte Real (N={N})')
    
    # Parte imaginaria
    plt.subplot(1, 3, 2)
    im2 = plt.imshow(np.imag(q_values.T), extent=[x_min, x_max, t_min, t_max], 
                    aspect='auto', origin='lower', cmap='RdBu_r')
    plt.colorbar(im2, label='Im(ψ)')
    plt.xlabel('Espacio (x)')
    plt.ylabel('Tiempo (t)')
    plt.title(f'Parte Imaginaria (N={N})')
    
    # Magnitud
    plt.subplot(1, 3, 3)
    im3 = plt.imshow(np.abs(q_values.T), extent=[x_min, x_max, t_min, t_max], 
                    aspect='auto', origin='lower', cmap='viridis')
    plt.colorbar(im3, label='|ψ|')
    plt.xlabel('Espacio (x)')
    plt.ylabel('Tiempo (t)')
    plt.title(f'Magnitud (N={N})')
    
    plt.tight_layout()
    plt.savefig(f'exact_solution_N{N}_verification.png', dpi=300, bbox_inches='tight')
    plt.show()
    
    return data

# Para generar ambas soluciones
if __name__ == "__main__":
    print("Generando soluciones exactas para NLSE...")
    
    # Generar solución para N=1
    print("\n" + "="*50)
    print("GENERANDO SOLUCIÓN PARA N=1")
    print("="*50)
    data_n1 = nonlinear_schrodinger_solution(N=1)
    
    # Generar solución para N=2
    print("\n" + "="*50)
    print("GENERANDO SOLUCIÓN PARA N=2")
    print("="*50)
    data_n2 = nonlinear_schrodinger_solution(N=2)
    
    
    print("Archivos creados: 'NLS_N1.mat' y 'NLS_N2.mat'")
                    </pre>
                </div>
            </section>
            
            <section id="referencias" class="section-card p-12">
                <h2 class="text-4xl font-bold text-gray-800 mb-8 text-center">Referencias</h2>
                <ul class="list-disc list-inside space-y-4 text-lg text-gray-600 max-w-4xl mx-auto">
                    <li>Satsuma, J., & Yajima, N. (1974). Initial Value Problems of One-Dimensional Self-Modulation of Nonlinear Waves in Dispersive Media. <em>Progress of Theoretical Physics Supplement</em>, 55, 284–306.</li>
                    <li>Raissi, M., Perdikaris, P., & Karniadakis, G. E. (2017). Physics Informed Deep Learning (Part I): Data-driven Solutions of Nonlinear Partial Differential Equations. <em>arXiv preprint arXiv:1711.10561</em>.</li>
                    <li><a href="https://github.com/maziarraissi/PINNs" class="text-blue-600 hover:underline">Repositorio de GitHub: PINNs de Maziar Raissi</a></li>
                    <li><a href="https://towardsdatascience.com/physics-informed-neural-networks-pinns-an-intuitive-guide-fff138069563" class="text-blue-600 hover:underline">Physics-Informed Neural Networks (PINNs): An Intuitive Guide</a> - Towards Data Science.</li>
                    <li><a href="https://physicsbaseddeeplearning.org/physicalloss-code.html" class="text-blue-600 hover:underline">Physics-Based Deep Learning Book: Physical Loss</a>.</li>
                    <li><a href="https://topbigdata.es/las-redes-neuronales-aprenden-a-acelerar-las-simulaciones-mayo-2022/" class="text-blue-600 hover:underline">Las redes neuronales aprenden a acelerar las simulaciones</a> - Top Big Data.</li>
                </ul>
            </section>

        </div>

    </main>

    <footer class="bg-gray-900 text-white py-12">
        <div class="container mx-auto px-6 text-center">
            <p class="text-gray-400">
                © 2024 Proyecto PINNs para NLS - Análisis Computacional Avanzado
            </p>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let currentN = 1;
            const x = Array.from({ length: 100 }, (_, i) => -5 + (10 * i) / 99);
            const t = Array.from({ length: 100 }, (_, i) => (i * Math.PI / 2) / 99);
            let spatialChart, temporalChart;

            const q1 = (x, t) => {
                const sech_x = 1 / Math.cosh(x);
                return {
                    real: sech_x * Math.cos(t / 2),
                    imag: sech_x * Math.sin(t / 2),
                    mod2: sech_x * sech_x
                };
            };

            const q2 = (x, t) => {
                // Compute numerator and denominator for N=2 solution (all real/imaginary parts explicit)
                const den = Math.cosh(4*x) + 4*Math.cosh(2*x) + 3*Math.cos(4*t);

                // Real and imaginary parts of the numerator
                const num_real_part1 = 4 * (Math.cosh(3*x) + 3*Math.cos(4*t)*Math.cosh(x));
                const num_imag_part1 = 4 * (3*Math.sin(4*t)*Math.cosh(x));
                const exp_real = Math.cos(0.5*t);
                const exp_imag = Math.sin(0.5*t);

                // Complex multiplication: (a+ib)*(c+id) = (ac-bd) + i(ad+bc)
                const final_real = (num_real_part1 * exp_real - num_imag_part1 * exp_imag) / den;
                const final_imag = (num_real_part1 * exp_imag + num_imag_part1 * exp_real) / den;
                
                return {
                    real: final_real,
                    imag: final_imag,
                    mod2: (final_real**2 + final_imag**2)
                };
            };
            
            const data_n1_mod2 = t.map(ti => x.map(xi => q1(xi, ti).mod2));
            const data_n2_mod2 = t.map(ti => x.map(xi => q2(xi, ti).mod2));
            const data_n1_real = t.map(ti => x.map(xi => q1(xi, ti).real));
            const data_n1_imag = t.map(ti => x.map(xi => q1(xi, ti).imag));
            const data_n2_real = t.map(ti => x.map(xi => q2(xi, ti).real));
            const data_n2_imag = t.map(ti => x.map(xi => q2(xi, ti).imag));

            const tSlider = document.getElementById('slider-t');
            const xSlider = document.getElementById('slider-x');
            const tValue = document.getElementById('t-value');
            const xValue = document.getElementById('x-value');
            const btnN1 = document.getElementById('btn-n1');
            const btnN2 = document.getElementById('btn-n2');
            const plotsN1 = document.getElementById('plots-n1');
            const plotsN2 = document.getElementById('plots-n2');

            const layout3d = (title) => ({ title, autosize: true, margin: { l: 0, r: 0, b: 20, t: 40 }, scene: { xaxis: { title: 'x' }, yaxis: { title: 't' }, zaxis: { title: '|h|²' } } });
            const layout2d = (title) => ({ title, autosize: true, margin: { l: 40, r: 20, b: 40, t: 40 }, xaxis: { title: 'x' }, yaxis: { title: 't' } });
            
            // N=1 Plots
            Plotly.newPlot('plot-n1-mod-3d', [{ z: data_n1_mod2, x: x, y: t, type: 'surface', colorscale: 'Viridis' }], layout3d(''));
            Plotly.newPlot('plot-n1-mod-2d', [{ z: data_n1_mod2, x: x, y: t, type: 'heatmap', colorscale: 'Viridis' }], layout2d(''));
            Plotly.newPlot('plot-n1-real-2d', [{ z: data_n1_real, x: x, y: t, type: 'heatmap', colorscale: 'RdBu' }], layout2d(''));
            Plotly.newPlot('plot-n1-imag-2d', [{ z: data_n1_imag, x: x, y: t, type: 'heatmap', colorscale: 'RdBu' }], layout2d(''));
            
            // N=2 Plots
            Plotly.newPlot('plot-n2-mod-3d', [{ z: data_n2_mod2, x: x, y: t, type: 'surface', colorscale: 'Plasma' }], layout3d(''));
            Plotly.newPlot('plot-n2-mod-2d', [{ z: data_n2_mod2, x: x, y: t, type: 'heatmap', colorscale: 'Plasma' }], layout2d(''));
            Plotly.newPlot('plot-n2-real-2d', [{ z: data_n2_real, x: x, y: t, type: 'heatmap', colorscale: 'RdBu' }], layout2d(''));
            Plotly.newPlot('plot-n2-imag-2d', [{ z: data_n2_imag, x: x, y: t, type: 'heatmap', colorscale: 'RdBu' }], layout2d(''));

            function createCharts() {
                const spatialCtx = document.getElementById('spatialChart').getContext('2d');
                spatialChart = new Chart(spatialCtx, {
                    type: 'line',
                    data: {
                        labels: x.map(v => v.toFixed(1)),
                        datasets: [
                            { label: 'Parte Real', data: [], borderColor: '#3b82f6', fill: false, pointRadius: 0, tension: 0.1 },
                            { label: 'Parte Imaginaria', data: [], borderColor: '#ef4444', fill: false, pointRadius: 0, tension: 0.1 },
                            { label: '|h|²', data: [], borderColor: '#10b981', borderDash: [5, 5], fill: false, pointRadius: 0, tension: 0.1 }
                        ]
                    },
                    options: { maintainAspectRatio: false, responsive: true, plugins: { legend: { position: 'top' } }, scales: { x: { title: { display: true, text: 'Posición (x)' } }, y: { title: { display: true, text: 'Amplitud' } } } }
                });

                const temporalCtx = document.getElementById('temporalChart').getContext('2d');
                temporalChart = new Chart(temporalCtx, {
                    type: 'line',
                    data: {
                        labels: t.map(v => v.toFixed(2)),
                        datasets: [
                            { label: 'Parte Real', data: [], borderColor: '#3b82f6', fill: false, pointRadius: 0, tension: 0.1 },
                            { label: 'Parte Imaginaria', data: [], borderColor: '#ef4444', fill: false, pointRadius: 0, tension: 0.1 },
                            { label: '|h|²', data: [], borderColor: '#10b981', borderDash: [5, 5], fill: false, pointRadius: 0, tension: 0.1 }
                        ]
                    },
                    options: { maintainAspectRatio: false, responsive: true, plugins: { legend: { position: 'top' } }, scales: { x: { title: { display: true, text: 'Tiempo (t)' } }, y: { title: { display: true, text: 'Amplitud' } } } }
                });
            }

            function updateLineCharts() {
                const t_idx = parseInt(tSlider.value);
                const x_idx = parseInt(xSlider.value);
                
                const realData = (currentN === 1) ? data_n1_real : data_n2_real;
                const imagData = (currentN === 1) ? data_n1_imag : data_n2_imag;
                const mod2Data = (currentN === 1) ? data_n1_mod2 : data_n2_mod2;

                tValue.textContent = t[t_idx].toFixed(3);
                xValue.textContent = x[x_idx].toFixed(2);

                // Update spatial chart
                spatialChart.data.datasets[0].data = realData[t_idx];
                spatialChart.data.datasets[1].data = imagData[t_idx];
                spatialChart.data.datasets[2].data = mod2Data[t_idx];
                spatialChart.options.plugins.title = { display: true, text: `Perfil en t = ${t[t_idx].toFixed(3)} (N=${currentN})`};
                spatialChart.update('none');

                // Update temporal chart
                temporalChart.data.datasets[0].data = realData.map(row => row[x_idx]);
                temporalChart.data.datasets[1].data = imagData.map(row => row[x_idx]);
                temporalChart.data.datasets[2].data = mod2Data.map(row => row[x_idx]);
                temporalChart.options.plugins.title = { display: true, text: `Evolución en x = ${x[x_idx].toFixed(2)} (N=${currentN})`};
                temporalChart.update('none');
            }


            btnN1.addEventListener('click', () => {
                currentN = 1;
                plotsN1.style.display = 'block';
                plotsN2.style.display = 'none';
                updateLineCharts();
                btnN1.classList.add('bg-blue-600', 'text-white');
                btnN1.classList.remove('bg-gray-200', 'text-gray-700');
                btnN2.classList.add('bg-gray-200', 'text-gray-700');
                btnN2.classList.remove('bg-blue-600', 'text-white');
            });
            
            btnN2.addEventListener('click', () => {
                currentN = 2;
                plotsN1.style.display = 'none';
                plotsN2.style.display = 'block';
                updateLineCharts();
                btnN2.classList.add('bg-blue-600', 'text-white');
                btnN2.classList.remove('bg-gray-200', 'text-gray-700');
                btnN1.classList.add('bg-gray-200', 'text-gray-700');
                btnN1.classList.remove('bg-blue-600', 'text-white');
            });

            tSlider.addEventListener('input', updateLineCharts);
            xSlider.addEventListener('input', updateLineCharts);

            // Inicialización
            createCharts();
            updateLineCharts();
            
            if (window.MathJax) {
                MathJax.typesetPromise();
            }
        });

// --- Framework Comparison Chart.js ---
        document.addEventListener('DOMContentLoaded', function () {
            const ctxComparison = document.getElementById('comparisonChart').getContext('2d');
            const comparisonChart = new Chart(ctxComparison, {
                type: 'bar',
                data: {
                    labels: ['TensorFlow 1', 'TensorFlow 2', 'PyTorch', 'PyTorch Optimizado'],                    datasets: [{
                        label: 'Tiempo de Entrenamiento (s)',
                        data: [362.24, 484.16, 369.10, 280.87],
                        backgroundColor: 'rgba(59, 130, 246, 0.7)', // blue-500
                        borderColor: 'rgba(30, 64, 175, 1)', // blue-800
                        borderWidth: 1,
                        yAxisID: 'yTime',
                    }, {
                        label: 'Error h (Error Total)',
                        data: [0.00231, 0.00772, 0.00301, 0.003146],
                        backgroundColor: 'rgba(239, 68, 68, 0.7)', // red-500
                        borderColor: 'rgba(153, 27, 27, 1)', // red-800
                        borderWidth: 1,
                        yAxisID: 'yLoss',
                    }]
                },
                options: {
                    responsive: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        yTime: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Tiempo (s)',
                                color: 'rgba(30, 64, 175, 1)'
                            },
                            grid: {
                                drawOnChartArea: false, 
                            },
                        },
                        yLoss: {
                            type: 'logarithmic',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Error Final (Escala Log)',
                                color: 'rgba(153, 27, 27, 1)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        if (context.dataset.yAxisID === 'yLoss') {
                                           label += context.parsed.y.toExponential(4);
                                        } else {
                                           label += context.parsed.y.toFixed(2) + ' s';
                                        }
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });            // --- 2-Soliton Comparison Chart ---
            const ctx2Soliton = document.getElementById('comparison2SolitonChart').getContext('2d');
            const comparison2SolitonChart = new Chart(ctx2Soliton, {
                type: 'bar',
                data: {
                    labels: ['TensorFlow 1', 'PyTorch', 'PyTorch Optimizado'],
                    datasets: [{
                        label: 'Tiempo de Entrenamiento (s)',
                        data: [1723.09, 2565.47, 561.31],
                        backgroundColor: 'rgba(147, 51, 234, 0.7)', // purple-600
                        borderColor: 'rgba(88, 28, 135, 1)', // purple-900
                        borderWidth: 1,
                        yAxisID: 'yTime',
                    }, {
                        label: 'Error h (Error Total)',
                        data: [0.007299, 0.01046, 0.009215],
                        backgroundColor: 'rgba(239, 68, 68, 0.7)', // red-500
                        borderColor: 'rgba(153, 27, 27, 1)', // red-800
                        borderWidth: 1,
                        yAxisID: 'yLoss',
                    }]
                },
                options: {
                    responsive: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        yTime: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Tiempo (s)',
                                color: 'rgba(88, 28, 135, 1)'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                        yLoss: {
                            type: 'logarithmic',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Error h (Escala Log)',
                                color: 'rgba(153, 27, 27, 1)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        if (context.dataset.yAxisID === 'yLoss') {
                                           label += context.parsed.y.toExponential(4);
                                        } else {
                                           label += context.parsed.y.toFixed(2) + ' s';
                                        }
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }            });
        });

        // --- Periodicity Comparison Charts ---
        document.addEventListener('DOMContentLoaded', function() {
            // Chart 1: Comparación de Errores L2 y Periodicidad
            const ctxPeriodicityComparison = document.getElementById('periodicityComparisonChart').getContext('2d');
            const periodicityComparisonChart = new Chart(ctxPeriodicityComparison, {
                type: 'bar',
                data: {
                    labels: ['Método A\n(Fourier)', 'Método B\n(Loss)', 'Método C\n(XPINN)'],
                    datasets: [
                        {
                            label: 'Error u (L2)',
                            data: [0.495, 0.496, 0.659],
                            backgroundColor: 'rgba(59, 130, 246, 0.7)',
                            borderColor: 'rgba(30, 64, 175, 1)',
                            borderWidth: 2
                        },
                        {
                            label: 'Error v (L2)',
                            data: [0.534, 0.535, 0.701],
                            backgroundColor: 'rgba(239, 68, 68, 0.7)',
                            borderColor: 'rgba(153, 27, 27, 1)',
                            borderWidth: 2
                        },
                        {
                            label: 'Error |ψ| (L2)',
                            data: [0.401, 0.402, 0.542],
                            backgroundColor: 'rgba(16, 185, 129, 0.7)',
                            borderColor: 'rgba(5, 150, 105, 1)',
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Comparación de Errores Relativos L2',
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(3);
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Error Relativo L2',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(2);
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Método PINN',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            }
                        }
                    }
                }
            });

            // Chart 2: Error de Periodicidad
            const ctxPeriodicityError = document.getElementById('periodicityErrorChart').getContext('2d');
            const periodicityErrorChart = new Chart(ctxPeriodicityError, {
                type: 'bar',
                data: {
                    labels: ['Método A\n(Fourier)', 'Método B\n(Loss)', 'Método C\n(XPINN)'],
                    datasets: [
                        {
                            label: 'Error Periódico u',
                            data: [0.004, 0.005, 0.013],
                            backgroundColor: 'rgba(147, 51, 234, 0.7)',
                            borderColor: 'rgba(88, 28, 135, 1)',
                            borderWidth: 2
                        },
                        {
                            label: 'Error Periódico |ψ|',
                            data: [0.006, 0.005, 0.079],
                            backgroundColor: 'rgba(245, 158, 11, 0.7)',
                            borderColor: 'rgba(180, 83, 9, 1)',
                            borderWidth: 2
                        },
                        {
                            label: 'Tiempo (min)',
                            data: [8.4, 11.0, 24.4],
                            backgroundColor: 'rgba(107, 114, 128, 0.5)',
                            borderColor: 'rgba(55, 65, 81, 1)',
                            borderWidth: 2,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Errores de Periodicidad y Tiempo de Entrenamiento',
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.dataset.yAxisID === 'y1') {
                                        label += context.parsed.y.toFixed(1) + ' min';
                                    } else {
                                        label += context.parsed.y.toFixed(3);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            type: 'logarithmic',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Error de Periodicidad (escala log)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toExponential(1);
                                }
                            }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Tiempo de Entrenamiento (min)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                drawOnChartArea: false
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1);
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Método PINN',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            }
                        }
                    }
                }
            });
        });
    </script>
</body>
</html>
`

